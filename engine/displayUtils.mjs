import inquirer from "inquirer"

import { bigString } from "./../wordstest.mjs"

import { display } from "./display.mjs"

export function textProcess (str) {


    // This takes strings and processes them for display.  It iterates over the string and analyses it character by character.

    // When it detects (sBRK) or (dBRK) at the current character + 5, it replaces them with spaces to create either single or 
    // double line breaks.

    // When it detects words that cross over lines, it add spaces before the words so that they start after the line break

    // It then converts the string into an array with each entry representing each line.

    // Finally it converts that shallow array into a deep array with pages represented as entries and lines as subentries

    // Importantly, it depends on a linelength variable  and page lines variable which are currently internal

    let lineLength = 60  
    let pageLines = 16   


    for (let i = 0; i < str.length; i ++) {
        
        let subStrBreak = (str.slice(0, i + 6))  // string used to check for breaks

        let subStrUnmodified = subStrBreak   // saves original version to be replaced in the main string

        if (/\(sBRK\)/.test(subStrBreak) === true || /\(dBRK\)/.test(subStrBreak) === true) { // break checker

            let breakIndex = (subStrBreak.match(/\(.BRK\)/)).index

            let spacesToAdd = (lineLength - (breakIndex % (lineLength))) 

            let spaceArray = []

            if (subStrBreak.match(/\(.BRK\)/)[0] === "(dBRK)") {  // if double break, add a line of whitespace

                spacesToAdd += lineLength
            }

            for (let j = 0; j < spacesToAdd; j ++) {
                spaceArray.push(' ')
            }


            subStrBreak = subStrBreak.replace(/\(.BRK\)/, spaceArray.join(''))

            str = str.replace(subStrUnmodified, subStrBreak)

        } 

        if ((i + 1)% lineLength === 0 && i > 1) {                              // word over line checker

            let lineEndChar = str[i]
            let lineBeginChar = str[i + 1]

            if (/\S/.test(lineEndChar) === true && /\S/.test(lineBeginChar)) {  // if line ends with letter and the next line beggins with one

                let whileLoop = true
                let spacesToAdd = 0

                while (whileLoop && spacesToAdd < lineLength) {  // tracks back and finds the last space

                    if (str[i - spacesToAdd] === " ") [

                        whileLoop = false
                    ]

                    else {

                        spacesToAdd ++
                    }


                    if (spacesToAdd === lineLength) {  // if the word is longer than a line, cancels to prevent infinite loop

                        spacesToAdd = 0
                        whileLoop = false
                    }


                }

                let spaceArray = []

                for (let j = 0; j < spacesToAdd; j ++) {

                    spaceArray.push(" ")


                }


                let arr = str.split('')

                arr.splice((i + 1) - spacesToAdd, 0, spaceArray.join(''))  // add the spaces in

                str = arr.join('')

            }


        }

        

        
    }

    // create the array


    let regex = new RegExp ( `\.{1,${lineLength}}`, "g")  

    let arr = str.match(regex)


    // divide the array into a deep array with pages

    let result = [[]]

    let arrTarget = 0

    for (let i in arr) {

        
        if (i % pageLines === 0 && i > 1) {
            
            result.push([])
            arrTarget ++
        }
        
        result[arrTarget].push(arr[i])
        

    }

    return result
}

export function arbitraryContinueGenerator (str) {

    /* This function takes an array generated by textProcess (which turns strings into nested arrays of lines in pages).  This 
    function then uses the continueConstructor function to add continue screens onto the stack.  The whole purpose of this is so that
    I can create exposition sections of any arbitrary length and not have to worry about how long the sections are or writing 
    individual inquirer prompt functions for each one or anything like that - string goes in, working continue prompt screens come out.*/

    let arr = textProcess(str)

    for (let i = arr.length - 1; i >= 0; i --) {

        stack.add(continueConstructor(arr[i], "Enter to continue..."))

    }
}

export function continueConstructor (forDisplayTxt, message) {

    // This is called by arbitraryContinueGenerator.  It uses closure to return functions which display the user part of a section 
    // of text and then prompts them to continue to see the next page of text.



    return function () {

        display.continue(forDisplayTxt)

        inquirer
        .prompt
        ([
            {
                name: "continueEnter",
                message: message
            }
        ])

        .then (answers => {

            if (answers.continueEnter === "") {

                this.remove()
                this.execute()

                return
            }
            else{

                this.execute()

                return
            }
        })

    }
}

export function arbitraryitemSelectGenerator (arr, destination, title) {

    /* This function takes an array of items, such as move objects, and then automatically generates a menu from them.
    Once an item is selected, the player will then be taken to the destination function with that item (for instance,
    if a player selects a move, they will then be taken to the learn move page for that particular move.)  These 
    menus can have multiple pages, thanks to the multiPageMenu functionality of the stack. */


    let pagesArr = []
    let page = -1

    let limit = 5

    for (let i = 0; i < arr.length; i ++) {

        if (i % limit === 0) {
            page ++

            pagesArr.push([])
        }

        pagesArr[page].push(arr[i])

    }

    let functionArr = []

    for (let i = 0; i < pagesArr.length; i ++) {

        functionArr.push(itemSelectConstructor(pagesArr[i], destination, title, pagesArr.length, (i + 1)))

    }

    stack.multiPageAdd(functionArr)

}

export function itemSelectConstructor (itemArr, destination, title, totalPages, currentPage) {

    /* Called by arbitrary item select generator.  Generates menu page functions for an arbitrary number of items.*/

    function MenuInvoker() { // here so that you dont have to edit it for all variations


        display.multiItem(itemArr, title)
    }

    if (totalPages === 1) {    // if only one page total

        return function () {

            MenuInvoker()
    
            let message = `Enter 1-${itemArr.length} to select, X to exit.`
    
    
    
    
    
            inquirer
            .prompt
            ([
                {
                    name: "itemSelect",
                    message: message
                }
            ])
    
            .then (answers => {
    
                if (parseInt(answers.itemSelect) > 0 && parseInt(answers.itemSelect) <= itemArr.length) {
    
                    this.multiPageRemove()
                    this.add(destination)
    
                    this.execute(itemArr[parseInt(answers.itemSelect) - 1])
    
                    return
                    
                }
                else if (answers.itemSelect.toUpperCase() === "X") {
    
                    this.multiPageRemove()
                    this.execute()
    
                    return
                    
                    
                }
    
                else {
    
                    this.execute()
    
                    return
                }
            })
    
        }


    }

    else if (totalPages > 1 && currentPage < totalPages && currentPage === 1) {  // if first page

        return function () {

            MenuInvoker()
    
            let message = `Enter 1-${itemArr.length} to select, N for next page and X to exit.`
    
    
    
    
    
            inquirer
            .prompt
            ([
                {
                    name: "itemSelect",
                    message: message
                }
            ])
    
            .then (answers => {
    
                if (parseInt(answers.itemSelect) > 0 && parseInt(answers.itemSelect) <= itemArr.length) {
    
                    this.multiPageRemove()
                    this.add(destination)
    
                    this.execute(itemArr[parseInt(answers.itemSelect) - 1])
    
                    return
                    
                }
                else if (answers.itemSelect.toUpperCase() === "X") {
    
                    this.multiPageRemove()
                    this.execute()
    
                    return
                    
                }
                else if (answers.itemSelect.toUpperCase() === "N") {
    
                    this.changePage("next")
    
                    return
                    
                }
    
                else {
    
                    this.execute()
    
                    return
                }
            })
    
        }

    }

    else if (totalPages > 1 && currentPage < totalPages && currentPage > 1) { // if middle pages

        return function () {

            MenuInvoker()
    
            let message = `Enter 1-${itemArr.length} to select, N for next page, P for previous page and X to exit.`
    
    
    
    
    
            inquirer
            .prompt
            ([
                {
                    name: "itemSelect",
                    message: message
                }
            ])
    
            .then (answers => {
    
                if (parseInt(answers.itemSelect) > 0 && parseInt(answers.itemSelect) <= itemArr.length) {
    
                    this.multiPageRemove()
                    this.add(destination)
    
                    this.execute(itemArr[parseInt(answers.itemSelect) - 1])
    
                    return
                    
                }
                else if (answers.itemSelect.toUpperCase() === "X") {
    
                    this.multiPageRemove()
                    this.execute()
    
                    return
                    
                }
                else if (answers.itemSelect.toUpperCase() === "N") {
    
                    this.changePage("next")
    
                    return
                    
                }
                else if (answers.itemSelect.toUpperCase() === "P") {
    
                    this.changePage("previous")
    
                    return
                    
                }
    
                else {
    
                    this.execute()
    
                    return
                }
            })
    
        }


    }

    else if (totalPages > 1 && currentPage === totalPages) { // if last page

        return function () {

            MenuInvoker()
    
            let message = `Enter 1-${itemArr.length} to select, P for previous page and X to exit.`
    
    
    
    
    
            inquirer
            .prompt
            ([
                {
                    name: "itemSelect",
                    message: message
                }
            ])
    
            .then (answers => {
    
                if (parseInt(answers.itemSelect) > 0 && parseInt(answers.itemSelect) <= itemArr.length) {
    
                    this.multiPageRemove()
                    this.add(destination)
    
                    this.execute(itemArr[parseInt(answers.itemSelect) - 1])
    
                    return
                    
                }
                else if (answers.itemSelect.toUpperCase() === "X") {
    
                    this.multiPageRemove()
                    this.execute()
    
                    return
                    
                }

                else if (answers.itemSelect.toUpperCase() === "P") {
    
                    this.changePage("previous")
    
                    return
                    
                }
    
                else {
    
                    this.execute()
    
                    return
                }
            })
    
        }


    }


    
}

export function multiDestinationMenuGenerator (itemArr) {  

    /* As yet uncreated function that will make the creating of menus in the game that have multiple destination options
    (such as a room with several doors) really easy.  Not sure if it will be necessary yet, but we will see. */


}
